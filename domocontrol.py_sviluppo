#!/usr/bin/python
import date
import time
import smbus
from db import Database
import datetime
import copy
import sht21
import os
import threading

OutChange = {}

A = {}
P = {}


class Domocontrol:
    """Class DomoControl"""

    def __init__(self):  # p = program dictionary
        self.db = Database()
        self.i2c = 0  # (dev/i2c_x) Default is 0 but getBusValue check for right value
        self.getBusValue()  # set /dev/i2c_x
        self.P = {}  # Dict with Program
        self.A = {}  # All unchanged db information
        self.IOThread = []  # List of active Thread
        self.t_board_id = ()  # Tupla con le board[id]
        self.t_board_address = ()  # Tupla con le board[address]
        self.t_board_type = ()  # Tupla con le board[type]
        self.t_board_io_address = ()  # Tupla address di ciascuna board[id]
        self.t_board_io_id = ()  # Tupla id di ciascuna board[id]
        self.l_board_io_val = []
        self.l_board_bin_val = []
        self.l_board_bin_onchange = []
        self.l_board_changerequest = []
        self.dir_root = os.path.dirname(os.path.abspath(__file__))  # path of program, to get icons
        self.initialize()  # Inizializza tuple, liste, dict

    def getBusValue(self):
        """
        Controlla il numero del divice I2C
        """
        print("Start getBusValue")
        self.device = []
        for a in range(0, 10):
            # print a
            try:
                self.i2c = smbus.SMBus(a)
                self.i2c = a  # address i2c /dev/i2c_x
                print('Device i2c: {}'.format(self.i2c))
            except:
                pass

    def read_i2c(self, board_address):
        """
        Ritorna il valore in byte dei dispositivi I2C.
        """
        bus = smbus.SMBus(self.i2c)
        return bus.read_byte(board_address)  # legge lo stato degli ingressi

    def write_i2c(self, board_address, val):
        bus = smbus.SMBus(self.i2c)
        bus.write_byte(board_address, val)

    def runIO(self, board_id, board_type_id):
        """
        Si occupa di leggere e scrivere i valori degli IO
        """
        # print self.l_board_bin_val, self.l_board_changerequest, self.l_board_bin_onchange
        if board_type_id == 0:  # Not used
            pass
        elif board_type_id == 1:  # I2C
            # print "I2C"
            val = self.read_i2c(self.t_board_address[board_id])
            self.l_board_bin_val[board_id] = val
            # print self.l_board_changerequest, self.l_board_changerequest[board_id], board_id
            if self.l_board_changerequest[board_id] == 1:
                self.l_board_bin_val[board_id] = self.l_board_bin_onchange[board_id]
                self.write_i2c(self.t_board_address[board_id], self.l_board_bin_val[board_id])

        elif board_type_id == 2:  # RS485
            pass
        elif board_type_id == 3:  # WEB
            # print "web"
            # Non fare nessuna operazione in quanto inizialmente di default, devono essere a 0.
            if self.l_board_changerequest[board_id] == 1:
                self.l_board_bin_val[board_id] = self.l_board_bin_onchange[board_id]
                self.l_board_changerequest[board_id] = 0


        elif board_type_id == 4 or board_type_id == 6:  # SHT21 Temperature
            temperature = round(sht21.SHT21(self.i2c).read_temperature(), 1)
            humidity = round(sht21.SHT21(self.i2c).read_humidity(), 1)
            self.l_board_bin_val[self.t_board_id[self.t_board_type[4]]] = temperature
            self.l_board_bin_val[self.t_board_id[self.t_board_type[6]]] = humidity
            time.sleep(10)
        elif board_type_id == 5:  # PD9535
            pass


        self.IOThread[board_id] = 0  # Rimuove il Thread dalla lista dei Thread in quanto e' terminato

    def InT(self, board_id, board_type):
        pass
        threading.Thread(target=self.runIO, args=(board_id, board_type)).start()

    def getIO(self):
        """
        Funzione chiamata da web.py che si occupa di inizializzare il Thread per la lettura dei valori.
            ** Funziona soo se le board hanno un ID progressivo e che inizia da 0. Da modificare **
        """
        for bid in self.t_board_id:
            if self.IOThread[bid] == 1:
                pass
            else:
                # print self.t_board_id, self.t_board_type
                self.IOThread[bid] = 1
                self.InT(bid, self.t_board_type[bid])

    def setClickData(self, data):
        """
        Called from web.py when clicked into I/O
        board_id, address, In value
        """
        IO = 0 if data[2] else 1
        self.l_board_bin_onchange[data[0]] = self.setBit(self.l_board_bin_onchange[data[0]], data[1], IO)
        self.l_board_changerequest[data[0]] = 1
        # print self.l_board_changerequest, self.l_board_bin_onchange, IO

    def now(self):
        """
        Ritorna l'ora corrente
        """
        return date.now()


    def initialize(self):  # program setup
        """
        Funzione di setup
        Imposta il valore di tutti i dizionari per il corretto funzionamento
        """
        print("Start Domocontrol Setup")

        # ********** Versione ottimizzata ***************
        # Tupla contenente le board_id, board_address, board_type
        q = 'SELECT * FROM board ORDER BY id'
        res = self.db.query(q)
        l_board_id = []
        l_board_address = []
        l_board_type = []
        self.l_board_bin_val = []
        self.l_board_bin_onchange = []
        self.l_board_changerequest = []
        for r in res:
            l_board_id.append(r['id'])
            l_board_address.append(r['address'])
            l_board_type.append(r['board_type_id'])
            self.l_board_bin_val.append(0)
            self.l_board_bin_onchange.append(0)
            self.IOThread.append(0)
            self.l_board_changerequest.append(0)
            self.t_board_id = tuple(l_board_id)
        self.t_board_address = tuple(l_board_address)
        self.t_board_type = tuple(l_board_type)
        # print self.t_board_id, self.t_board_address, self.t_board_type

        # Tupla contenente le board_io separate dalle board
        #   board 0    board 1....
        # ((0,1,2,x), (0,1,2x), ...)
        q = 'SELECT id, address, board_id FROM board_io ORDER BY board_id, address'
        res = self.db.query(q)
        l_board_io_address = []
        l_board_io_id = []
        l_board_io_val = []
        tmp_address = []
        tmp_id = []
        tmp_val = []
        self.t_board_io_address = ()
        self.l_board_io_id = ()
        for lb in l_board_id:
            for r in res:
                if r['board_id'] == lb:
                    tmp_address.append(r['address'])
                    tmp_id.append(r['id'])
                    tmp_val.append(0)
            l_board_io_address.append(tuple(tmp_address))
            l_board_io_id.append(tuple(tmp_id))
            self.l_board_io_val.append(tmp_val)
            tmp_address = []
            tmp_id = []
            tmp_val = []
        self.t_board_io_address = tuple(l_board_io_address)
        self.l_board_io_id = tuple(l_board_io_id)
        # print self.t_board_io_address
        # print self.t_board_io_id
        # print self.l_board_io_val


        # ********** Vecchia versione ***************
        # Board informations
        q = 'SELECT * FROM board'
        res = self.db.query(q)
        self.A['board'] = {}
        for r in res:
            self.A['board'].update({r['id']: r})
            OutChange[r['id']] = {}

        # Board_IO informations
        q = 'SELECT * FROM board_io'
        res = self.db.query(q)
        self.A['board_io'] = {}
        for r in res:
            # print r['id']
            self.A['board_io'].update({r['id']: r})

        # icon list
        icon_path = os.path.join(self.dir_root, 'static/icon')
        files = [fn for fn in os.listdir(icon_path)]
        self.A['icon'] = files

        # program data
        q = 'SELECT id, in_id, delay, inverted, out_id, type_id, name, description, timer, chrono, enable FROM program WHERE enable = 1'
        res = self.db.query(q)
        self.P = {}
        for r in res:
            self.P.update({r['id']: r})
            self.P[r['id']].update({'TA': 0})

        # Area informations
        q = 'SELECT id, name, description, sort FROM area ORDER BY sort'
        res = self.db.query(q)
        self.A['area'] = {}
        for r in res:
            self.A['area'].update({r['id']: r})

        # Area + other info SORTED #Menu_status
        q = 'SELECT a.id AS area_id, a.name AS area_name, a.description AS area_description, \
                bio.id AS  board_io_id,  bio.io_type_id AS board_io_io_type_id, bio.name AS board_io_name, bio.description AS board_io_description, bio.address AS board_io_address,   \
                bio.board_id AS board_io_board_id, bio.icon_on AS board_io_icon_on, bio.icon_off AS board_io_icon_off \
            FROM board_io AS bio \
                LEFT JOIN area AS a ON bio.area_id=a.id \
            ORDER BY a.sort'
        res = self.db.query(q)
        self.A['area_board_io'] = {}
        for r in res:
            self.A['area_board_io'].update({r['board_io_id']: r})

        # IO_Type informations
        q = 'SELECT id, type, name, description FROM io_type'
        res = self.db.query(q)
        self.A['io_type'] = {}
        for r in res:
            self.A['io_type'].update({r['id']: r})

        # Board_type informations
        q = 'SELECT * FROM board_type'
        res = self.db.query(q)
        self.A['board_type'] = {}
        for r in res:
            self.A['board_type'].update({r['id']: r})

        # Program_type informations
        q = 'SELECT * FROM program_type'
        res = self.db.query(q)
        self.A['program_type'] = {}
        for r in res:
            self.A['program_type'].update({r['id']: r})
        global A, P
        A = self.A
        P = self.P

        print("End Domocontrol Setup")


    def getData(self, data):  # Ritorna il dato richiesto chiamato da web.py
        return eval(data)


    # New Version #
    # dictionary definition:
    # Self.A = contain all database information
    # self.IO = in / out / sensor value
    # self.P = program database
    def loop(self):  # Loop principale
        # self.getInStatus()  # Leggo lo stato delle schede e aggiorno dizionario se e' cambiato
        ## print self.IO['io']  # stampo dizionario
        # self.updateIO()  # aggiorna in self.IO['board_io'] lo stato dei singoli ingressi / uscite
        ## print self.IO['board_io']
        # self.updateOut()
        pass

    def getInStatus(self):
        """
        Get Byte Status of all board
        Legge il valore degli ingressi/uscite delle varie schede
        """
        #~ print self.A
        #~ print
        #~ print self.IO
        #~ print
        #~ print self.P

        for board_id in self.A['board']:  # get status of boards
            board = self.A['board'][board_id]


            if int(board['board_type_id']) == 1:  # i2c board
                bus = smbus.SMBus(self.i2c)
                data = bus.read_byte(int(board['address']))  # legge lo stato degli ingressi
                data_old = self.IO['io'][board['id']]['value']

                if data != data_old:
                    diff = int(data) ^ int(data_old)
                    # print "Diff : ", diff
                    self.IO['io'].update({board['id']: {'value': data, 'update': diff}})  # aggiorna  dizionario

            elif int(board['board_type_id']) == 2:  # RS485 board
                pass  # To Do
                self.IO['io'].update({board['id']: 0})
            elif int(board['board_type_id']) == 3:  # WEB - virtual board
                self.IO['io'].update({board['id']: {'value': 0, 'update': 0}})  # aggiorna  dizionario

            elif int(board['board_type_id']) == 5:  # PD9535
                """
                bus = smbus.SMBus(self.i2c)
                print dir(bus)
                for x in range(0,10):
                    try:
                        pass
                        # bus.write_byte(int(board['address']), x)
                    except:
                        pass
                data = bus.read_byte_data(int(board['address']),0) #legge lo stato degli ingressi
                print data
                """
                pass

                # self.IO['io'].update({board['id']: {'value': 0, 'update': 0 }}) #aggiorna  dizionario

    def updateIO(self):
        """
        funzione che aggiorna self.IO['board_io']
        """

        for board_id, data in self.IO['io'].iteritems():  # iterazione degli IO (byte)
            #~ print board_id, data
            address = 0
            while data['update'] > 0:  # se update e' >0 significa che e' cambiato lo stato IO
                if data['update'] & 1 == 1:  # se 1 il bit meno significativo e' cambiato
                    board_io_id = self.M['board_io_m'].get((board_id, address), 0)  # seleziono il board_io_id da cambiare
                    if board_io_id > 0:  # se >0 il board_io_id e' mappato, esiste nel database
                        bit_value = self.getBitValue(data['value'], address)  # vede il valore del bit cambiato
                        self.IO['board_io'][board_io_id]['SA'] = bit_value  # imposta lo stato del bit nel dizionario
                data['update'] = int(data['update']) / 2  # divide per 2 il data['update'] per vedere il secondo bit
                address += 1


    """
    def updateOut(self):

        for pid, data in self.P.iteritems():
            # print self.IO['io'], self.IO['board_io'][data['out_id']]
            # print pid, data

            type_id = data['type_id']  # program.type_id
            inverted = 1 if data['inverted'] == 1 else 0
            out_board_io_id = self.IO['board_io'][data['out_id']]['id']
            out_board_id = self.IO['board_io'][out_board_io_id]['board_id']
            out_address = self.IO['board_io'][out_board_io_id]['address']
            # print "out_board_io_id:", out_board_io_id, "  out_board_id:", out_board_id, "   out_address:", out_address

            if type_id == 1:  # timer: luci scale: incomincia a decrementare quando il pulsante torna a 0
                # print pid, data, '\n',  self.IO['board_io'][data['in_id']],'\n',  self.IO['board_io'][data['out_id']]
                if self.IO['board_io'][data['in_id']]['SA'] and self.IO['board_io'][data['in_id']]['TA'] == 0:
                    timer = data['timer']
                    timer = timer.split('-')
                    timer = (int(timer[0]) * 24 * 3600) + (int(timer[1]) * 3600) + (int(timer[2]) * 60) + int(timer[3])
                    data['TA'] = timer

                if data['TA'] > 0:
                    out_status = inverted ^ 1
                    self.IO['board_io'][data['out_id']]['SA'] = out_status
                    self.setBit(self.IO['board_io'][data['out_id']]['board_id'], self.IO['board_io'][data['out_id']]['address'], out_status)

                else:
                    out_status = int(not (inverted ^ 1))
                    self.IO['board_io'][data['out_id']]['SA'] = out_status
                    self.setBit(self.IO['board_io'][data['out_id']]['board_id'], self.IO['board_io'][data['out_id']]['address'], out_status)

            elif type_id == 2:  # timeout
                # print "Timeout", pid, data, '\n',  self.IO['board_io'][data['in_id']],'\n',  self.IO['board_io'][data['out_id']]
                if self.IO['board_io'][data['in_id']]['SA'] and self.IO['board_io'][data['in_id']]['SP'] == '':
                    timer = data['timer']
                    timer = timer.split('-')
                    timer = (int(timer[0]) * 24 * 3600) + (int(timer[1]) * 3600) + (int(timer[2]) * 60) + int(timer[3])
                    data['TA'] = timer
                    self.IO['board_io'][data['in_id']]['SP'] = 1
                if self.IO['board_io'][data['in_id']]['SA'] == 0 and self.IO['board_io'][data['in_id']]['SP'] == 1:
                    self.IO['board_io'][data['in_id']]['SP'] = ''

                if data['TA'] > 0:
                    out_status = inverted ^ 1
                else:
                    out_status = int(not (inverted ^ 1))

                self.IO['board_io'][data['out_id']]['SA'] = out_status
                byte = self.setBit(self.IO['io'][out_board_id]['value'], out_address, out_status)
                if byte != self.IO['io'][out_board_id]['value']:
                    self.setIO(out_board_id, byte)

            elif type_id == 3:  # automatic
                # print "Automatic", pid, data, '\n',  self.IO['board_io'][data['in_id']],'\n',  self.IO['board_io'][data['out_id']]
                chrono = data['chrono'].split(';')
                chronoOpen = 0
                date = self.now().strftime('%Y-%m-%d')
                for ch in chrono:
                    c = ch.split('-')
                    fd = c.pop(0)
                    fh = c.pop(0)
                    fm = c.pop(0)
                    fs = c.pop(0)

                    td = c.pop(0)
                    th = c.pop(0)
                    tm = c.pop(0)
                    ts = c.pop(0)

                    tfrom = '{} {}:{}:{}'.format(date, fh, fm, fs)
                    tto = '{} {}:{}:{}'.format(date, th, tm, ts)

                    FMT = '%Y-%m-%d %H:%M:%S'

                    timefrom = datetime.datetime.strptime(tfrom, FMT)
                    timeto = datetime.datetime.strptime(tto, FMT)

                    daynow = self.now().weekday()  # Day of week
                    # print "From: ", tfrom, "\nTo:   ", tto, "\nNow:  ", self.now()

                    if (int(fd) == 7 and int(td) == 7 and self.now() > timefrom and self.now() < timeto) or (int(daynow) >= int(fd) and int(daynow) <= int(td) and self.now() > timefrom and self.now() < timeto):
                        chronoOpen = 1
                if chronoOpen == 1:
                    out_status = inverted ^ 1
                else:
                    out_status = int(not (inverted ^ 1))

                self.IO['board_io'][data['out_id']]['SA'] = out_status
                byte = self.setBit(self.IO['io'][out_board_id]['value'], out_address, out_status)
                if byte != self.IO['io'][out_board_id]['value']:
                    self.setIO(out_board_id, byte)

            elif type_id == 4:  # manual
                # print pid, data, '\n',  self.IO['board_io'][data['in_id']],'\n',  self.IO['board_io'][data['out_id']]
                out_status = inverted ^ self.IO['board_io'][data['in_id']]['SA']
                self.IO['board_io'][data['out_id']]['SA'] = out_status
                byte = self.setBit(self.IO['io'][out_board_id]['value'], out_address, out_status)
                if byte != self.IO['io'][out_board_id]['value']:
                    self.setIO(out_board_id, byte)
    """

    def counter(self):
        """
        Funzione che decrementa i timer interni al programma
        """
        for p in self.P:
            if self.P[p]['TA'] > 0:
                self.P[p]['TA'] -= 1

    """
    def getSensorStatus(self): Rimuovere

        # print "----------------- Get Sensor Values ---------------"
        for board_id in self.A['board']:  # get status of boards
            board = self.A['board'][board_id]
            if int(board['board_type_id']) == 4:  # SHT21 Temperature / Humidity sensor
                try:
                    board_io_id = self.M['board_io_m'].get((board_id, 0), 0)  # return board_io_id temperature
                    if board_io_id > 0:
                        temperature = round(sht21.SHT21(i2c).read_temperature(), 1)
                        self.IO['board_io'][board_io_id]['SA'] = temperature
                        q = 'INSERT INTO sensor (type, value) VALUES("{}", "{}");'.format('1', temperature)
                        self.db.query(q)

                    board_io_id = self.M['board_io_m'].get((board_id, 1), 0)  # return board_io_id humidity
                    if board_io_id > 0:
                        humidity = round(sht21.SHT21(self.i2c).read_humidity(), 1)
                        self.IO['board_io'][board_io_id]['SA'] = humidity


                except:  # initialize self.tnow and set temp + hum immediately
                    print "getSensorStatus Error"
    """

    def getBitValue(self, byteval, idx):
        """
        Return if bit in the byte is 0 or 1
        Ritorna il valore del BIT di un Byte
        """
        return 1 if (byteval & (1 << idx)) != 0 else 0

    def setBit(self, byte, index, x):
        """
        Set bit of byte to x
        Setta a 0 o a 1 il bit di un byte
        Example:  (0b0000, 2, 1) = 0b0100
        Example:  (0b0111, 2, 0) = 0b0011
        """
        mask = 1 << index
        # print byte, mask, x
        if x:
            byte |= mask
        else:
            byte ^= mask

        # print byte, mask, x
        return byte

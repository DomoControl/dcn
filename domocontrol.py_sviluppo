#!/usr/bin/python
import date
import time
import smbus
from db import Database
import datetime
import copy
import sht21
import os

class Domocontrol:
    """Class DomoControl"""

    def __init__(self):  # p = program dictionary
        self.db = Database()
        self.mapping = [0, 1, 2, 4, 8, 16, 32, 64, 128]
        
        self.i2c = 0  # (dev/i2c_x) Default is 0 but getBusValue check for right value
        self.getBusValue() #set /dev/i2c_x
        
        self.B = {} #IN / OUT value
        self.BCopy = {} #Copy B dictionary
        
        self.C = {} #Sensor value
        self.CCopy = {} #Copy C dictionary
        
        self.S = {}
        self.SCopy = {}
        
        self.P = {}  # Dict with Program
        self.PCopy = {}  #Copy P dictionary
        
        self.A = {}  # All unchanged db information        
        self.ACopy = {} #Copy A dictionary
        
        self.IO = {'io':{}, 'sensor':{}, 'board_io':{}} #Content IO status (menu status)
        self.IOCopy = {'io':{}, 'sensor':{}, 'board_io':{}} #Copy IO dictionary
        self.IOCopy8 = {1:1}
        
        self.M = {} #matrix dict
        self.MCopy = {}
        
        self.n = 0
        
        self.dir_root = os.path.dirname(os.path.abspath(__file__)) #path of program
        
        self.setup()
        #~ self.initializeIO()

    def now(self):
        """
        Ritorna l'ora corrente
        """
        return date.now()

    def getBusValue(self):
        """
        Controlla il numero del divice I2C
        """
        print("Start getBusValue")
        self.device = []
        for a in range(0, 10):
            # print a
            try:
                i2c = smbus.SMBus(a)
                self.i2c = a  # address i2c /dev/i2c_x
                print('Device i2c: {}'.format(self.i2c))
            except:
                pass

    def setup(self):  # program setup
        """
        Funzione di setup
        Imposta il valore di tutti i dizionari per il corretto funzionamento
        """
        print("Start Domocontrol Setup")
        
        #Dict IO['io']
        q_board = 'SELECT * FROM board WHERE board_type_id=1 OR board_type_id=2 OR board_type_id=3'
        r_board = self.db.query(q_board)
        for rr_board in r_board:
            #~ print rr_board, r_board
            self.IO['io'].update( {rr_board['id']: {'value':0, 'update':0} })
        
        #Dict IO['board_io']
        q_board_io = 'SELECT * FROM board_io'
        r_board_io = self.db.query(q_board_io)
        for rr_board_io in r_board_io:
            self.IO['board_io'].update( {rr_board_io['id']: {
                'id':rr_board_io['id'], 
                'io_type_id':rr_board_io['io_type_id'],
                'board_id':rr_board_io['board_id'],
                'address':rr_board_io['address'],
                'SA':0, #Stato attuale
                'TA':0, #Timer
                } 
            })
        
        #Board_io DICT with all i
        self.A['board_io'] = {}
        self.IO['timer'] = {}
        q_board_io = 'SELECT * FROM board_io' # WHERE id=13'
        r_board_io = self.db.query(q_board_io)
        for rr_board_io in r_board_io:
            
            q_io_type = 'SELECT * FROM io_type WHERE id=%s' %rr_board_io['io_type_id']
            r_io_type = self.db.query(q_io_type)[0]
            
            q_board = 'SELECT * FROM board WHERE id=%s' %rr_board_io['board_id']
            r_board = self.db.query(q_board)[0]
            
            q_area = 'SELECT * FROM area WHERE id=%s' %rr_board_io['area_id']
            r_area = self.db.query(q_area)[0]
            
            self.A['board_io'].update( {rr_board_io['id']: { 
                    'id':rr_board_io['id'] ,
                    'io_type': r_io_type ,
                    'name': rr_board_io['name'] ,
                    'description': rr_board_io['description'] ,
                    'enable': rr_board_io['enable'] ,
                    'timestamp': rr_board_io['timestamp'] ,
                    'board': r_board,
                    'address': rr_board_io['address'] ,
                    'area': r_area,
                    'icon_on': rr_board_io['icon_on'],
                    'icon_off': rr_board_io['icon_off']
                }
            })
        
        #matrix board_io_m to get board_io.id for board and address
        """
        Matrix Dict to get quickly data
        """
        self.M.update({'board_io_m': {} })
        q = 'SELECT * FROM board_io'
        r = self.db.query(q)
        for rr in r:
            self.M['board_io_m'].update({(int(rr['board_id']), int(rr['address'])): int(rr['id'])})
        #~ print self.M['board_io_m']
        
        #Select program_id form in_id
        self.M.update({'program_m': {} })
        q = 'SELECT * FROM program'
        r = self.db.query(q)
        for rr in r:
            self.M['program_m'].update({int(rr['in_id']): int(rr['id'])})
        
        #-------------- End Matrix
        
        
        #icon list
        icon_path =  os.path.join(self.dir_root, 'static/icon')
        files = [fn for fn in os.listdir(icon_path) ];
        self.A['icon'] = files
        
        # program data
        q = 'SELECT id, in_id, delay, inverted, out_id, type_id, name, description, timer, chrono, enable FROM program WHERE enable = 1'
        res = self.db.query(q)
        self.P = {}
        for r in res:
            #~ self.P[r['id']] = r
            #~ self.P[r['id']].update({'IN': r['inverted'], 'OUT': 0})
            self.P.update({r['id']: r})

        # Area informations
        q = 'SELECT id, name, description FROM area'
        res = self.db.query(q)
        self.A['area'] = {}
        for r in res:
            self.A['area'].update({r['id']: r})
        
        # IO_Type informations    
        q = 'SELECT id, type, name, description FROM io_type'
        res = self.db.query(q)
        self.A['io_type'] = {}
        for r in res:
            self.A['io_type'].update({r['id']: r})

        # Board informations
        q = 'SELECT * FROM board'
        res = self.db.query(q)
        self.A['board'] = {}
        for r in res:
            self.A['board'].update({r['id']: r})

        # Board_type informations
        q = 'SELECT * FROM board_type'
        res = self.db.query(q)
        self.A['board_type'] = {}
        for r in res:
            self.A['board_type'].update({r['id']: r})
            
        # Program_type informations
        q = 'SELECT * FROM program_type'
        res = self.db.query(q)
        self.A['program_type'] = {}
        for r in res:
            self.A['program_type'].update({r['id']: r})
            
        print("End Domocontrol Setup")

    def getDict(self, dictionary, reloadDict=False): #Send DICT to web.py when request. If Dict is equal, send empty.
        #~ print self.P[4]
        if dictionary == 'P':
            if self.PCopy == self.P and reloadDict==False:
                #~ print "P Uguale"
                return {}
            else:
                #~ print "P diverso"
                self.PCopy = copy.deepcopy(self.P)
                return self.P
                
        elif dictionary == 'A':
            if self.A == self.ACopy and reloadDict==False:
                return {}
            else:
                self.ACopy = copy.deepcopy(self.A)
                return self.A
                
        elif dictionary == 'IO':
            if self.IO == self.IOCopy and reloadDict==False:
                return {}
            else:
                self.IOCopy = copy.deepcopy(self.IO)
                return self.IO
            
        elif dictionary == 'B':
            if self.B == self.BCopy and reloadDict==False:
                return {}
            else:
                self.BCopy = copy.deepcopy(self.B)
                return self.B
        
        elif dictionary == 'C':
            if self.C == self.CCopy and reloadDict==False:
                return {}
            else:
                self.CCopy = copy.deepcopy(self.C)
                return self.C



    ##### New Version #####
    
    def loop(self): #Loop principale
        self.getInStatus() #Leggo lo stato delle schede e aggiorno dizionario se e' cambiato
        #~ print self.IO['io'] #stampo dizionario
        self.updateIO() #aggiorna in self.IO['board_io'] lo stato dei singoli ingressi / uscite
        #~ print self.IO['board_io']

    def getInStatus(self):
        """
        Get Byte Status of all board
        Legge il valore degli ingressi/uscite delle varie schede
        """
        for board_id in self.A['board']: #get status of boards
            board = self.A['board'][board_id]
            
            if int(board['board_type_id']) == 1:  # i2c board
                bus = smbus.SMBus(self.i2c)
                data = bus.read_byte(int(board['address'])) #legge lo stato degli ingressi
                data_old = self.IO['io'][board['id']]['value']
                if data != data_old:
                    diff = int(data) ^ int(data_old)
                    #~ print "Diff :", diff
                    self.IO['io'].update({board['id']: {'value': data, 'update': diff }}) #aggiorna  dizionario
                    
            elif int(board['board_type_id']) == 2:  # RS485 board
                pass  # To Do
                self.IO['io'].update({board['id']: 0})
            elif int(board['board_type_id']) == 3:  # WEB - virtual board
                self.IO['io'].update({board['id']: {'value': 0, 'update': 0 }}) #aggiorna  dizionario
   
    def updateIO(self):
        """
        funzione che aggiorna self.IO['board_io'] 
        """
        for board_id, data in self.IO['io'].iteritems(): #iterazione degli IO (byte)
            address = 0
            while data['update'] > 0: #se update e' >0 significa che e' cambiato lo stato IO
                if data['update'] & 1 == 1: #se 1 il bit meno significativo e' cambiato
                    board_io_id = self.M['board_io_m'].get((board_id, address), 0) #seleziono il board_io_id da cambiare
                    if board_io_id > 0: #se >0 il board_io_id e' mappato, esiste nel database
                        bit_value = self.getBitValue(data['value'], address) #vede il valore del bit cambiato
                        self.IO['board_io'][board_io_id]['SA'] = bit_value #imposta lo stato del bit nel dizionario
                data['update'] = int(data['update'])/2 #divide per 2 il data['update'] per vedere il secondo bit
                address += 1
            self.IO['io'][board_id]['update'] = 0 #0 significa che le operazioni sono state eseguite

    def getSensorStatus(self):
        """
        Legge i valori dei vari sensori
        """
        #~ print "----------------- Get Sensor Values ---------------"
        for board_id in self.A['board']: #get status of boards
            board = self.A['board'][board_id]
            if int(board['board_type_id']) == 4:  # SHT21 Temperature / Humidity sensor
                try:
                    board_io_id = self.M['board_io_m'].get((board_id, 0), 0) #return board_io_id temperature
                    self.IO['board_io'][board_io_id]['SA'] = round(sht21.SHT21(self.i2c).read_temperature(),1)
                    
                    board_io_id = self.M['board_io_m'].get((board_id, 1), 0) #return board_io_id humidity
                    if board_io_id > 0:
                        self.IO['board_io'][board_io_id]['SA'] =  round(sht21.SHT21(self.i2c).read_humidity(),1)
                except: #initialize self.tnow and set temp + hum immediately
                    print "getSensorStatus Error"

        
    def getBitValue(self, byteval, idx): 
        """
        Return if bit in the byte is 0 or 1
        Ritorna il valore del BIT di un Byte
        """
        return 1 if (byteval&(1<<idx))!=0 else 0

                    
    def setBit(self, byte, index, x): #forse non serve e si puo' cancellare
        """
        Set bit of byte to x 
        Setta a 0 o a 1 il bit di un byte
        Example:  (0b0000, 2, 1) = 0b0100
        Example:  (0b0111, 2, 0) = 0b0011
        """
        byte = int(byte)
        index = int(index)
        mask = 1 << index
        byte &= ~mask
        
        if x:
            byte |= mask
        return byte
     
    def setIO(self,update):
        """
        Set I2C status
        """  
        for u in update:
            address = int(self.A['board'][u]['address'])
            data = int(self.IO['io'][u])
            print address, bin(data)
            bus = smbus.SMBus(self.i2c)
            bus.write_byte(address, data)
     


    def programUpdate(self, board_io_id, bitVal, board_id): 
        """
        Setta le uscite in base al valore degli ingressi
        """
        itid = int(self.A['board_io'][board_io_id]['io_type']['id']) #check is board_io is input
        program_id = self.M['program_m'].get(board_io_id, 0)
        if (itid == 0 or itid == 1) and program_id > 0 : #board_io_id e' un ingresso
            print board_id, board_io_id, bitVal, itid, program_id, self.IO 
            type_id = self.P[program_id]['type_id']
        
            #~ print "Type_id: %s   In_in: %s" %(type_id, board_io_id)
            out_id = self.P[program_id]['out_id']
            inverted = self.P[program_id]['inverted']
            if inverted:
                bitVal = not bitVal
            
            if type_id == 1: #Timer
                print "Timer"
                print self.P[program_id]
                if bitVal == 1:
                    print "TIMER 111111111111111"
                    self.IO['board_io'].update({out_id: int(bitVal)})
                    timer = self.P[program_id]['timer']
                    timer = timer.split('-')
                    timer = (int(timer[0]) * 24 * 3600) + (int(timer[1]) * 3600) + (int(timer[2]) * 60) + int(timer[3])
                    self.IO['timer'].update({board_io_id: timer})
                
                else:
                    print "TIMER 000000000000000", out_id, int(bitVal)
                    self.IO['board_io'].update({out_id: int(bitVal)})
                                
            elif  type_id == 2: #Timeout
                print "Timeout"
                pass
            elif  type_id == 3: #Automatic
                print "Automatic"
                pass
            elif  type_id == 4: #Manuale
                self.IO['board_io'].update({out_id: int(bitVal)})
                pass           
     
     
    def counter(self):
        #~ print "counter", self.IO['timer']   
        
        for board_io_id in self.IO['timer']:
            program_id = self.M['program_m'][board_io_id]
            bitVal = self.IO['board_io'][board_io_id]
            board_id = self.A['board_io'][board_io_id]['board']['id']
            
            print "board_io_id:", board_io_id, "  program_id:", program_id, "  bitVal:", bitVal, "  board_id", board_id
            
            if self.IO['timer'][board_io_id] > 0:
                self.IO['timer'][board_io_id] = self.IO['timer'][board_io_id] - 1
            else:
                
                self.programUpdate(board_io_id, int(0), board_id )
                del self.IO['timer'][board_io_id]
            
            if len(self.IO['timer']) == 0:
                return    
     
    #dictionary definition:
    #Self.A = contain all database information
    #self.IO = in / out / sensor value
    #self.P = program database
    def loop1(self):
        update = {}
        for p in self.P:  # p = id of self.P
            #~ print self.P
            out_id = self.P[p]['out_id'] #get board_io_id OUTPUT
            in_id = self.P[p]['in_id'] #get board_io_id INPUT
            out_board_id = self.A['board_io'][out_id]['board']['id']
            out_address = self.A['board_io'][out_id]['address']
            
            if self.P[p]['type_id'] == 4:  # 4 = Manual
                inverted = 0 if int(self.P[p]['inverted']) == int(self.IO['board_io'][self.P[p]['in_id']]) else 1  # Status inverted is flag inverted = 1
                if inverted:
                    update[out_board_id]=out_board_id #setto su "update" il dizionario che e' cambiato
                    self.IO['board_io'].update({out_id: 0}) #aggiorno lo stato dell'uscita del dizionario board_io
                    self.IO['io'].update({out_board_id: self.setBit(self.IO['io'][out_board_id], out_address, 0)}) #aggiorno il dizionario io
                else:
                    update[out_board_id]=out_board_id
                    self.IO['board_io'].update({self.P[p]['out_id']: not inverted})
                    self.IO['io'].update({out_board_id: self.setBit(self.IO['io'][out_board_id], out_address, 1)})
        
            elif self.P[p]['type_id'] == 1:  # 1 = Timer (luci scale)
                print "Timer Luci Scale"
                #~ print "Self.P", self.P[p]
                #~ print "board_io_m", self.IO
                
                if self.IO['board_io'][self.P[p]['in_id']] == 1:
                    timer = self.P[p]['timer'].split('-')
                    timer = (int(timer[0]) * 24 * 3600) + (int(timer[1]) * 3600) + (int(timer[2]) * 60) + int(timer[3])
                    self.IO['timer'].update({in_id: timer})
                    print "TIMER", in_id, timer
                    
                #~ in_address = self.getAddress('in_id', p)
                #~ out_address = self.getAddress('out_id', p)
                #~ in_status = self.IOStatus(in_address)
                #~ self.P[p]['IN'] = in_status
                
                #~ if int(in_status) == 1:
                    #~ timer = self.P[p]['timer'].split('-')
                    #~ timer = (int(timer[0]) * 24 * 3600) + (int(timer[1]) * 3600) + (int(timer[2]) * 60) + int(timer[3])
                    #~ if 'TIMER' in self.P[p]:
                        #~ self.P[p].update({'TIMER': timer})
                    #~ else:
                        #~ self.P[p]['TIMER'] = timer
                    #~ self.setIO(out_address, not int(self.P[p]['inverted']))
#~ 
                #~ if 'TIMER' in self.P[p] and int(self.P[p]['TIMER']) > 0:
                    #~ self.P[p]['TIMER'] = int(self.P[p]['TIMER']) - 1
                #~ else:
                    #~ if 'TIMER' in self.P[p]:
                        #~ del self.P[p]['TIMER']
                    #~ self.setIO(out_address, int(self.P[p]['inverted']))
                #~ 

        self.setIO(update)

        """

                
            elif self.P[p]['type_id'] == 2:  # 2 = Timeout (Pompa irrigazione)
                #~ print self.P[p]
                in_address = self.getAddress('in_id', p)
                out_address = self.getAddress('out_id', p)
                in_status = self.IOStatus(in_address)
                self.P[p]['IN'] = in_status

                if int(self.P[p]['IN']) == 1:
                    if 'TIMER' in self.P[p]:
                        if int(self.P[p]['TIMER']) > 0:
                            self.P[p]['TIMER'] = int(self.P[p]['TIMER']) - 1
                            self.setIO(out_address, (not int(self.P[p]['inverted'])))
                        else:
                            self.setIO(out_address, int(self.P[p]['inverted']))
                    else:
                        timer = self.P[p]['timer'].split('-')
                        timer = (int(timer[0]) * 24 * 3600) + (int(timer[1]) * 3600) + (int(timer[2]) * 60) + int(timer[3])
                        self.P[p].update({'TIMER': timer})
                else:
                    if 'TIMER' in self.P[p]:
                        del self.P[p]['TIMER']
                    self.setIO(out_address, int(self.P[p]['inverted']))


            elif self.P[p]['type_id'] == 3:  # 3 = Automatic
                in_address = self.getAddress('in_id', p)
                out_address = self.getAddress('out_id', p)
                in_status = self.IOStatus(in_address)
                self.P[p]['IN'] = in_status

                date = self.now().strftime('%Y-%m-%d')
                chrono = self.P[p]['chrono'].split(';')
                chronoOpen = 0
                for ch in chrono:
                    c = ch.split('-')
                    fd = c.pop(0)
                    fh = c.pop(0)
                    fm = c.pop(0)
                    fs = c.pop(0)

                    td = c.pop(0)
                    th = c.pop(0)
                    tm = c.pop(0)
                    ts = c.pop(0)

                    tfrom = '{} {}:{}:{}'.format(date, fh, fm, fs)
                    tto = '{} {}:{}:{}'.format(date, th, tm, ts)

                    FMT = '%Y-%m-%d %H:%M:%S'

                    timefrom = datetime.datetime.strptime(tfrom, FMT)
                    timeto = datetime.datetime.strptime(tto, FMT)

                    daynow = self.now().weekday() #Day of week

                    if (int(fd) == 7 and int(td) == 7 and self.now() > timefrom and self.now() < timeto) or (int(daynow) >= int(fd) and int(daynow) <= int(td) and self.now() > timefrom and self.now() < timeto):
                        chronoOpen = 1

                in_stat = 0 if int(self.P[p]['inverted']) == chronoOpen else 1  # Status inverted is flag inverted = 1
                self.setIO(out_address, in_stat)
        """
        
        
        
        #look in there are temperature sensor
        """
        try:
            tdiff = self.now() - self.tnow
            if tdiff.total_seconds() > 432: #Get data every 5 minutes
                self.tnow = self.now()
                for t in self.A['board']: 
                    if self.A['board'][t]['board_type_id'] == 4: #SHT21 sensor Temparature + Humidity
                        print self.A['board_io']
                        q = 'INSERT INTO sensor (type, value) VALUES("{}", "{}");'.format('1', round(sht21.SHT21(self.i2c).read_temperature(),1) )
                        print q
                        self.db.query(q)
                        q = 'INSERT INTO sensor (type, value) VALUES("{}", "{}");'.format('2', round(sht21.SHT21(self.i2c).read_humidity(),1) )
                        self.db.query(q)
                        print q
                        
        except:
            self.tnow = self.now() #crea la variabile self.tnow se non esiste
        """
        #~ timeend=self.now()
        #~ print "Time cycle: ", timeend-timebegin
        #~ print '-'*80


    ###### End NEW VERSION
